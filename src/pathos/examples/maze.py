# src/pathos/examples/maze.py

"""
2D Grid / Maze Search Domain for Pathos AI.

This module defines a classic grid-based navigation problem, suitable for:
- Breadth-First Search (BFS)
- Depth-First Search (DFS)
- Uniform-Cost Search (UCS)
- A* Search (with a heuristic)

It demonstrates:
- A Goal-Oriented problem
- A Cost-Sensitive problem
- A clean separation between domain logic and search algorithms
- SOLID principles: Maze handles domain logic, MazeRenderer handles visualization
"""

from typing import List, Tuple, Set
from pathos.core import GoalOriented, CostSensitive

# --- State Representation ---
# A state is a pair of integer coordinates (x, y)
# representing the agent's position in the grid.
#
# Coordinate system:
#   (0, 0) → top-left corner
#   x increases to the right
#   y increases downward


State = Tuple[int, int]  # (x, y)


class Maze(CostSensitive[State, str], GoalOriented[State, str]):
    """
    A 2D grid maze with walls and uniform movement cost.

    The agent can move in four cardinal directions:
    - UP
    - DOWN
    - LEFT
    - RIGHT

    Each move has a uniform cost of 1.0, but the class
    explicitly supports weighted search algorithms
    by implementing the CostSensitive protocol.

    This class follows the Single Responsibility Principle:
    it handles domain logic only. For visualization, see MazeRenderer.
    """

    def __init__(
        self,
        length: int = 10,
        width: int = 10,
        walls: Set[State] = set(),
        start: State = (0, 0),
        goal: State = (9, 9),
    ):
        """
        Initialize the maze domain.

        Parameters
        ----------
        length : int
            Length of the grid (number of rows).
        width : int
            Width of the grid (number of columns).
        walls : Set[State]
            Set of blocked cells that cannot be traversed.
        start : State
            Initial position of the agent.
        goal : State
            Target position to reach.
        """
        self.length = length
        self.width = width
        self.walls = walls

        # Internal (private) storage for required properties
        self._initial_state = start
        self._goal_state = goal

    # --- Initial State ---

    @property
    def initial_state(self) -> State:
        """
        Return the initial state of the maze.

        Required by the SearchDomain / GoalOriented protocol.
        """
        return self._initial_state

    # --- Action Generator ---

    def actions(self, state: State) -> List[str]:
        """
        Return all legal actions available from the given state.

        An action is legal if:
        - The resulting position is inside the grid bounds
        - The resulting position is not a wall

        Parameters
        ----------
        state : State
            Current position (x, y).

        Returns
        -------
        List[str]
            List of valid action names.
        """
        x, y = state

        # Candidate moves and their resulting coordinates
        candidates = [
            ("UP", (x - 1, y)),
            ("DOWN", (x + 1, y)),
            ("LEFT", (x, y - 1)),
            ("RIGHT", (x, y + 1)),
        ]

        valid_actions: List[str] = []

        for action_name, (nx, ny) in candidates:
            # Check grid bounds
            if 0 <= nx < self.length and 0 <= ny < self.width:
                # Check for walls
                if (nx, ny) not in self.walls:
                    valid_actions.append(action_name)

        return valid_actions

    def result(self, state, action):
        """
        Apply an action to a state and return the resulting state.

        Assumes the action is valid and was generated by `actions()`.

        Parameters
        ----------
        state : State
            Current position.
        action : str
            Action to apply.

        Returns
        -------
        State
            New position after applying the action.
        """

        x, y = state

        match action:
            case "UP":
                return (x - 1, y)
            case "DOWN":
                return (x + 1, y)
            case "LEFT":
                return (x, y - 1)
            case "RIGHT":
                return (x, y + 1)

        # Defensive fallback (should never be reached)
        return state

    # --- Cost Function ---

    def step_cost(self, state: State, action: str, next_state: State) -> float:
        """
        Return the cost of taking an action.

        Currently all moves have uniform cost = 1.0.
        This method exists to support cost-based algorithms
        like UCS and A*.

        Parameters
        ----------
        state : State
            Current state.
        action : str
            Action taken.
        next_state : State
            Resulting state.

        Returns
        -------
        float
            Cost of the action.
        """
        return 1.0

    # --- Goal State ---

    def is_goal(self, state: State) -> bool:
        """
        Check whether the given state is the goal state.

        Parameters
        ----------
        state : State
            Current position in the grid.

        Returns
        -------
        bool
            True if the state matches the goal location.
        """
        return state == self._goal_state

    # --- Representation ---

    def __repr__(self) -> str:
        """
        Developer-friendly string representation of the maze.

        Shows core configuration without rendering the full grid.
        Useful for debugging and logging.
        """
        return (
            f"Maze(length={self.length}, width={self.width}, "
            f"start={self._initial_state}, goal={self._goal_state}, "
            f"walls={len(self.walls)})"
        )


# --- Visualization (Separate Responsibility) ---


class MazeRenderer:
    """
    Handles ASCII visualization of Maze problems.

    This class is separated from Maze to follow the Single Responsibility Principle:
    - Maze class: Domain logic (state transitions, goal checking, costs)
    - MazeRenderer class: Presentation logic (ASCII visualization)

    This separation means:
    - Maze can change its domain logic without affecting visualization
    - Renderer can change display format without touching domain logic
    - Easy to add new renderers (HTML, GUI) without modifying Maze
    """

    @staticmethod
    def render(maze: Maze, path: Set[State] | None = None) -> str:
        """
        Return a human-friendly ASCII visualization of the maze.

        Parameters
        ----------
        maze : Maze
            The maze to visualize.
        path : Optional[Set[State]]
            States belonging to a solution path.
            These will be rendered with '*'.

        Returns
        -------
        str
            Multiline string representing the maze.

        Example
        -------
        >>> maze = Maze(length=5, width=5, start=(0, 0), goal=(4, 4))
        >>> print(MazeRenderer.render(maze))
        S · · · ·
        · · · · ·
        · · · · ·
        · · · · ·
        · · · · G
        """
        path = path or set()
        lines: list[str] = []

        for x in range(maze.length):
            row: list[str] = []
            for y in range(maze.width):
                cell = (x, y)

                if cell == maze._initial_state:
                    row.append("S")
                elif cell == maze._goal_state:
                    row.append("G")
                elif cell in path:
                    row.append("*")
                elif cell in maze.walls:
                    row.append("█")
                else:
                    row.append("·")

            lines.append(" ".join(row))

        return "\n".join(lines)


# --- Heuristics ---


def manhattan_distance(a: State, b: State) -> float:
    """
    Manhattan distance heuristic.

    Also known as the "taxicab" distance.
    It measures the distance between two points in a grid
    assuming movement is restricted to horizontal and vertical steps.

    h(n) = |x1 - x2| + |y1 - y2|

    This heuristic is:
    - Admissible (never overestimates)
    - Consistent (monotonic)
    for 4-connected grid movement with uniform costs.

    Parameters
    ----------
    a : State
        First position.
    b : State
        Second position.

    Returns
    -------
    float
        Estimated cost from a to b.
    """
    return abs(a[0] - b[0]) + abs(a[1] - b[1])


def manhattan_heuristic(goal: State):
    """
    Create a Manhattan-distance heuristic bound to a specific goal.

    This is a factory function that returns a heuristic function
    specialized for a particular goal state.

    Parameters
    ----------
    goal : State
        The goal position to calculate distances to.

    Returns
    -------
    Callable[[State], float]
        A heuristic function that estimates distance to the goal.

    Example
    -------
    >>> h = manhattan_heuristic((9, 9))
    >>> h((0, 0))  # Distance from (0,0) to (9,9)
    18.0
    """

    def h(state: State) -> float:
        return abs(state[0] - goal[0]) + abs(state[1] - goal[1])

    return h
