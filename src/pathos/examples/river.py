# src/pathos/examples/river.py

"""
River Crossing Puzzle (Farmer, Wolf, Goat, Cabbage).

This module defines the classic river crossing puzzle as a Goal-Oriented
search problem compatible with the Pathos AI framework.

The puzzle constraints:
- A farmer must transport a wolf, a goat, and a cabbage across a river.
- The boat can carry the farmer alone or the farmer plus exactly one item.
- The wolf cannot be left alone with the goat.
- The goat cannot be left alone with the cabbage.
"""

from typing import List, Tuple
from pathos.core import GoalOriented

# --- State Representation ---
# A state is a 4-tuple of integers:
# (Farmer, Wolf, Goat, Cabbage)
#
# Each value represents the river bank:
#   0 = Left bank
#   1 = Right bank
#
# Example:
#   (0, 1, 0, 1)
#   Farmer and Goat on the left bank,
#   Wolf and Cabbage on the right bank.

State = Tuple[int, int, int, int]  # (Farmer, Wolf, Goat, Cabbage)


class RiverPuzzle(GoalOriented[State, str]):
    # --- Initial State ---

    @property
    def initial_state(self) -> State:
        """
        Return the initial state of the puzzle.

        All entities start on the left bank.
        """
        return (0, 0, 0, 0)

        # --- State Validity Check ---

    def is_valid(self, state: State) -> bool:
        """
        Determine whether a state is valid according to puzzle constraints.

        Invalid situations:
        - The wolf is left alone with the goat (farmer absent).
        - The goat is left alone with the cabbage (farmer absent).

        Parameters
        ----------
        state : State
            The state to validate.

        Returns
        -------
        bool
            True if the state is valid, False otherwise.
        """
        farmer, wolf, goat, cabbage = state

        # Wolf eats Goat if Farmer is not present
        if wolf == goat and farmer != wolf:
            return False

        # Goat eats Cabbage if Farmer is not present
        if goat == cabbage and farmer != goat:
            return False

        return True

    # Action Generator

    def actions(self, state: State) -> List[str]:
        """
        Generate all valid actions available from a given state.

        The farmer may:
        - Move alone
        - Take the wolf
        - Take the goat
        - Take the cabbage

        Only actions that lead to valid states are returned.
        """
        possible_moves: List[str] = []

        farmer, wolf, goat, cabbage = state
        new_farmer = 1 - farmer  # Farmer crosses the river

        # 1. Farmer moves alone
        if self.is_valid((new_farmer, wolf, goat, cabbage)):
            possible_moves.append("Move Farmer")

        # 2. Farmer takes the Wolf (must be on the same side)
        if farmer == wolf:
            new_state = (new_farmer, new_farmer, goat, cabbage)
            if self.is_valid(new_state):
                possible_moves.append("Take Wolf")

        # 3. Farmer takes the Goat
        if farmer == goat:
            new_state = (new_farmer, wolf, new_farmer, cabbage)
            if self.is_valid(new_state):
                possible_moves.append("Take Goat")

        # 4. Farmer takes the Cabbage
        if farmer == cabbage:
            new_state = (new_farmer, wolf, goat, new_farmer)
            if self.is_valid(new_state):
                possible_moves.append("Take Cabbage")

        return possible_moves

    def result(self, state: State, action: str) -> State:
        """
        Apply an action to a state and return the resulting state.

        This method assumes the action is valid and generated by `actions()`.

        Parameters
        ----------
        state : State
            The current state.
        action : str
            The action to apply.

        Returns
        -------
        State
            The resulting state after applying the action.
        """
        farmer, wolf, goat, cabbage = state
        new_farmer = 1 - farmer

        if action == "Move Farmer":
            return (new_farmer, wolf, goat, cabbage)

        if action == "Take Wolf":
            return (new_farmer, new_farmer, goat, cabbage)

        if action == "Take Goat":
            return (new_farmer, wolf, new_farmer, cabbage)

        if action == "Take Cabbage":
            return (new_farmer, wolf, goat, new_farmer)

        # Defensive fallback (should never be reached)
        return state

    def is_goal(self, state):
        return state == (1, 1, 1, 1)
